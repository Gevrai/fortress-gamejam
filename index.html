<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>Fortress Defense</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#111;touch-action:none;user-select:none;font-family:monospace}
#c{display:block;margin:0 auto}
#hud{position:fixed;bottom:0;left:0;right:0;background:#222;color:#eee;display:flex;align-items:center;justify-content:space-around;padding:6px 2px;font-size:13px;z-index:10;flex-wrap:wrap;gap:4px}
#hud button{background:#444;color:#eee;border:2px solid #666;padding:6px 10px;font-size:13px;font-family:monospace;border-radius:4px;min-width:60px}
#hud button.sel{border-color:#ff0;color:#ff0}
#hud button:active{background:#555}
#info{text-align:center;width:100%;font-size:12px;margin-bottom:2px}
#overlay{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,.85);display:flex;flex-direction:column;align-items:center;justify-content:center;color:#eee;z-index:20;font-family:monospace;text-align:center}
#overlay h1{font-size:28px;margin-bottom:16px}
#overlay p{font-size:16px;margin-bottom:12px}
#overlay button{background:#555;color:#ff0;border:2px solid #ff0;padding:12px 32px;font-size:20px;font-family:monospace;border-radius:6px;margin-top:10px}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud">
 <div id="info"></div>
 <button id="bWall">Wall 5g</button>
 <button id="bTurret">Turret 15g</button>
 <button id="bPit">Pit 10g</button>
 <button id="bRemove">Remove</button>
 <button id="bNight">Start Night</button>
</div>
<div id="overlay"><h1>Fortress Defense</h1><p>Protect the princess from being kidnapped!<br>Build walls by day, place turrets by night.<br>Survive 5 nights to win.</p><button id="bStart">START</button></div>
<script>
const canvas=document.getElementById('c'),ctx=canvas.getContext('2d');
const COLS=20,ROWS=32;
const BASE_TILE=16;
let TILE=BASE_TILE,offX=0,offY=0;
let camX=0,camY=0,zoom=1,minZoom=.5,maxZoom=2;
let grid=[],entities=[],projectiles=[],floatingTexts=[];
let phase='day',nightNum=0,gold=50,score=0;
let selectedTool='wall';
let flowToPrincess=null,flowToPortals=null;
let princessPos={x:10,y:16},princessHome={x:10,y:16};
let princessGrabbed=false,princessCarrier=null;
let waveTimer=0,waveCount=0,wavesTotal=0,nightActive=false;
let gameState='title'; // title, playing, win, lose
let spawnQueue=[];

// --- Resize ---
function resize(){
 const hud=document.getElementById('hud').offsetHeight||60;
 canvas.width=window.innerWidth;
 canvas.height=window.innerHeight-hud;
 // fit default zoom so map fills screen width
 const fitZoom=Math.min(canvas.width/(COLS*BASE_TILE),canvas.height/(ROWS*BASE_TILE));
 minZoom=fitZoom*.8;maxZoom=fitZoom*3;
 if(zoom<minZoom)zoom=minZoom;
 if(!window._zoomInit){zoom=fitZoom;camX=(COLS*BASE_TILE)/2;camY=(ROWS*BASE_TILE)/2;window._zoomInit=true;}
}
window.addEventListener('resize',resize);

// --- Grid ---
function initGrid(){
 grid=[];
 for(let y=0;y<ROWS;y++){grid[y]=[];for(let x=0;x<COLS;x++)grid[y][x]='empty';}
 princessPos={x:6,y:10};princessHome={x:6,y:10};
 grid[princessHome.y][princessHome.x]='princess';
 princessGrabbed=false;princessCarrier=null;
 entities=[];projectiles=[];floatingTexts=[];spawnQueue=[];
 // scatter terrain
 const terrainTypes=['tree','rock','water'];
 let placed=0;
 while(placed<60){
  const x=Math.random()*COLS|0,y=Math.random()*ROWS|0;
  if(grid[y][x]!=='empty')continue;
  // keep a clear zone around princess
  if(Math.abs(x-princessHome.x)<=2&&Math.abs(y-princessHome.y)<=2)continue;
  const t=terrainTypes[Math.random()*3|0];
  grid[y][x]=t;
  placed++;
 }
}

function addPortal(){
 // random edge tile that is empty
 let attempts=0;
 while(attempts++<200){
  let side=Math.random()*4|0;
  let x,y;
  if(side===0){x=Math.random()*COLS|0;y=0;}
  else if(side===1){x=Math.random()*COLS|0;y=ROWS-1;}
  else if(side===2){x=0;y=Math.random()*ROWS|0;}
  else{x=COLS-1;y=Math.random()*ROWS|0;}
  if(grid[y][x]==='empty'){
   grid[y][x]='portal';
   const dist=bfs([{x,y}]);
   if(dist[princessHome.y][princessHome.x]===Infinity){grid[y][x]='empty';continue;}
   return;
  }
 }
}

// --- BFS Flow Fields ---
function neighbors(x,y){
 const n=[];
 if(x>0)n.push({x:x-1,y});if(x<COLS-1)n.push({x:x+1,y});
 if(y>0)n.push({x,y:y-1});if(y<ROWS-1)n.push({x,y:y+1});
 return n;
}
function isWalkable(x,y){const t=grid[y][x];return t!=='wall'&&t!=='turret'&&t!=='tree'&&t!=='rock'&&t!=='water';}

function bfs(starts){
 // returns dist map & parent map
 const dist=Array.from({length:ROWS},()=>new Float32Array(COLS).fill(Infinity));
 const q=[];
 for(const s of starts){dist[s.y][s.x]=0;q.push(s);}
 let qi=0;
 while(qi<q.length){
  const{x,y}=q[qi++];
  for(const n of neighbors(x,y)){
   if(isWalkable(n.x,n.y)&&dist[n.y][n.x]===Infinity){
    dist[n.y][n.x]=dist[y][x]+1;
    q.push(n);
   }
  }
 }
 return dist;
}

function calcFlowFields(){
 flowToPrincess=bfs([princessGrabbed?princessPos:princessHome]);
 // flow to nearest portal
 const portals=[];
 for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++)if(grid[y][x]==='portal')portals.push({x,y});
 flowToPortals=portals.length?bfs(portals):null;
}

function canPlace(x,y){
 // temporarily block this tile, check path from princess to any portal
 const old=grid[y][x];
 grid[y][x]='wall';
 const portals=[];
 for(let gy=0;gy<ROWS;gy++)for(let gx=0;gx<COLS;gx++)if(grid[gy][gx]==='portal')portals.push({x:gx,y:gy});
 const dist=bfs([princessHome]);
 let ok=false;
 for(const p of portals)if(dist[p.y][p.x]<Infinity){ok=true;break;}
 grid[y][x]=old;
 return ok;
}

// --- Enemies ---
function spawnEnemy(px,py,type){
 type=type||'normal';
 let hp,speed,size;
 if(type==='normal'){hp=3+nightNum*2;speed=3.5+nightNum*.4;size=.35;}
 else if(type==='tank'){hp=10+nightNum*5;speed=1.8+nightNum*.2;size=.5;}
 else if(type==='flyer'){hp=2+nightNum;speed=3+nightNum*.3;size=.25;}
 entities.push({x:px+.5,y:py+.5,hp,maxHp:hp,type,
  state:'moving_to_princess',speed,grabTimer:0,
  slowTimer:0,pitCooldown:0,size,flyOffset:0});
}

function stepEnemies(dt){
 for(let i=entities.length-1;i>=0;i--){
  const e=entities[i];
  if(e.hp<=0){
   // drop princess if carrying
   if(e===princessCarrier){
    princessGrabbed=false;princessCarrier=null;
    // princess walks back (instant for simplicity)
    princessPos={...princessHome};
   }
   gold+=5+nightNum;score+=10;
   floatingTexts.push({x:e.x,y:e.y,text:`+${5+nightNum}g`,timer:1,color:'#ff0'});
   entities.splice(i,1);continue;
  }
  let speed=e.speed*dt;
  if(e.slowTimer>0){speed*=.4;e.slowTimer-=dt;}

  // pit damage (flyers immune)
  const tx=e.x|0,ty=e.y|0;
  if(e.type!=='flyer'&&tx>=0&&tx<COLS&&ty>=0&&ty<ROWS&&grid[ty][tx]==='pit'&&e.pitCooldown<=0){
   e.hp-=2;e.slowTimer=1.5;e.pitCooldown=2;
   floatingTexts.push({x:e.x,y:e.y,text:'PIT!',timer:.8,color:'#f80'});
  }
  if(e.pitCooldown>0)e.pitCooldown-=dt;

  // junction bonus
  if(tx>=0&&tx<COLS&&ty>=0&&ty<ROWS){
   let openN=0;
   for(const n of neighbors(tx,ty))if(isWalkable(n.x,n.y))openN++;
   if(openN>=3&&!e._lastJunction||(e._lastJunction&&(e._lastJunction.x!==tx||e._lastJunction.y!==ty))){
    if(openN>=3){gold+=2;score+=5;
     floatingTexts.push({x:e.x,y:e.y-.5,text:'+2g',timer:.8,color:'#0f0'});
     e._lastJunction={x:tx,y:ty};
    }
   }
  }

  if(e.state==='moving_to_princess'){
   const flow=flowToPrincess;
   if(!flow)continue;
   moveAlongFlow(e,flow,speed);
   // check if reached princess
   const dx=e.x-princessPos.x-.5,dy=e.y-princessPos.y-.5;
   if(!princessGrabbed&&dx*dx+dy*dy<.3){
    e.state='grabbing';e.grabTimer=1;
   }
  }else if(e.state==='grabbing'){
   e.grabTimer-=dt;
   if(e.grabTimer<=0){
    e.state='carrying_to_portal';
    princessGrabbed=true;princessCarrier=e;
    // Remove princess from grid
    grid[princessHome.y][princessHome.x]='empty';
    calcFlowFields();
   }
  }else if(e.state==='carrying_to_portal'){
   if(!flowToPortals)continue;
   moveAlongFlow(e,flowToPortals,speed*.6);
   princessPos={x:e.x-.5,y:e.y-.5};
   // check if reached portal
   const etx=e.x|0,ety=e.y|0;
   if(etx>=0&&etx<COLS&&ety>=0&&ety<ROWS&&grid[ety][etx]==='portal'){
    gameState='lose';
   }
  }
 }
}

function moveAlongFlow(e,flow,speed){
 if(e.type==='flyer'){
  // fly straight toward target (ignore walls)
  let tx,ty;
  if(e.state==='carrying_to_portal'||e.state==='moving_to_princess'&&princessGrabbed){
   // find nearest portal
   let best=Infinity;tx=e.x;ty=e.y;
   for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++)if(grid[y][x]==='portal'){
    const d=(e.x-x-.5)**2+(e.y-y-.5)**2;if(d<best){best=d;tx=x+.5;ty=y+.5;}
   }
  }else{tx=princessPos.x+.5;ty=princessPos.y+.5;}
  const dx=tx-e.x,dy=ty-e.y,dist=Math.sqrt(dx*dx+dy*dy);
  if(dist>.05){e.x+=dx/dist*Math.min(speed,dist);e.y+=dy/dist*Math.min(speed,dist);}
  e.flyOffset=Math.sin(Date.now()/150)*3;
  return;
 }
 const cx=e.x|0,cy=e.y|0;
 let bestD=flow[cy]?flow[cy][cx]:Infinity;
 let bx=cx,by=cy;
 for(const n of neighbors(cx,cy)){
  if(!isWalkable(n.x,n.y))continue;
  const d=flow[n.y][n.x];
  if(d<bestD||(d===bestD&&Math.random()<.3)){bestD=d;bx=n.x;by=n.y;}
 }
 const tx=bx+.5,ty=by+.5;
 const dx=tx-e.x,dy=ty-e.y;
 const dist=Math.sqrt(dx*dx+dy*dy);
 if(dist>.05){e.x+=dx/dist*Math.min(speed,dist);e.y+=dy/dist*Math.min(speed,dist);}
}

// --- Turrets ---
function stepTurrets(dt){
 for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++){
  if(grid[y][x]!=='turret')continue;
  // find turret data
  if(!grid[y]._turrets)grid[y]._turrets={};
  if(!grid[y]._turrets[x])grid[y]._turrets[x]={cd:0};
  const t=grid[y]._turrets[x];
  t.cd-=dt;
  if(t.cd>0)continue;
  // find nearest enemy in range 3.5
  let best=null,bestD=3.5*3.5;
  for(const e of entities){
   const dx=e.x-(x+.5),dy=e.y-(y+.5),d2=dx*dx+dy*dy;
   if(d2<bestD){bestD=d2;best=e;}
  }
  if(best){
   t.cd=.5;
   projectiles.push({x:x+.5,y:y+.5,tx:best.x,ty:best.y,timer:.2,target:best,dmg:2+Math.floor(nightNum/2)});
  }
 }
}

function stepProjectiles(dt){
 for(let i=projectiles.length-1;i>=0;i--){
  const p=projectiles[i];
  p.timer-=dt;
  // lerp
  const prog=1-Math.max(0,p.timer)/.2;
  p.cx=p.x+(p.tx-p.x)*prog;
  p.cy=p.y+(p.ty-p.y)*prog;
  if(p.timer<=0){
   if(p.target&&p.target.hp>0)p.target.hp-=p.dmg;
   projectiles.splice(i,1);
  }
 }
}

// --- Floating Text ---
function stepFloatingTexts(dt){
 for(let i=floatingTexts.length-1;i>=0;i--){
  const f=floatingTexts[i];
  f.timer-=dt;f.y-=dt*.8;
  if(f.timer<=0)floatingTexts.splice(i,1);
 }
}

// --- Wave Management ---
function startNight(){
 if(phase==='night')return;
 phase='night';nightNum++;
 const total=4+nightNum*3;
 wavesTotal=total;waveCount=0;
 spawnQueue=[];
 const portals=[];
 for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++)if(grid[y][x]==='portal')portals.push({x,y});
 for(let i=0;i<total;i++){
  const p=portals[i%portals.length];
  let type='normal';
  if(i%5===4)type='tank';
  else if(i%4===3)type='flyer';
  spawnQueue.push({x:p.x,y:p.y,delay:1+i*1,type});
 }
 nightActive=true;waveTimer=0;
 calcFlowFields();
 selectedTool='turret';updateButtons();
}

function stepWaves(dt){
 if(!nightActive)return;
 waveTimer+=dt;
 for(let i=spawnQueue.length-1;i>=0;i--){
  if(waveTimer>=spawnQueue[i].delay){
   spawnEnemy(spawnQueue[i].x,spawnQueue[i].y,spawnQueue[i].type);
   waveCount++;spawnQueue.splice(i,1);
  }
 }
 if(spawnQueue.length===0&&entities.length===0){
  // night over
  nightActive=false;
  if(nightNum>=5){gameState='win';return;}
  phase='day';
  addPortal();
  // restore princess if not grabbed
  if(!princessGrabbed){grid[princessHome.y][princessHome.x]='princess';}
  gold+=15;
  selectedTool='wall';updateButtons();
  calcFlowFields();
 }
}

// --- Render ---
const COLORS={
 empty_day:'#5a8f3c',empty_night:'#2a4f2c',
 wall:'#888',turret:'#66f',pit:'#3a2010',
 princess:'#f8a',portal:'#a0f',
 enemy:'#e33',enemyCarry:'#f80'
};

function render(){
 const night=phase==='night';
 TILE=BASE_TILE*zoom;
 ctx.fillStyle=night?'#1a2a1a':'#3a6a2a';
 ctx.fillRect(0,0,canvas.width,canvas.height);
 ctx.save();
 ctx.translate(canvas.width/2-camX*zoom,canvas.height/2-camY*zoom);

 // tiles
 for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++){
  const t=grid[y][x];
  const px=x*TILE,py=y*TILE;
  if(t==='empty'){
   ctx.fillStyle=night?COLORS.empty_night:COLORS.empty_day;
   ctx.fillRect(px,py,TILE,TILE);
  }else if(t==='wall'){
   ctx.fillStyle=COLORS.wall;ctx.fillRect(px,py,TILE,TILE);
   // brick pattern
   ctx.fillStyle='#777';
   ctx.fillRect(px,py+TILE/2-1,TILE,2);
   ctx.fillRect(px+TILE/2-1,py,2,TILE/2);
   ctx.fillRect(px+TILE/4-1,py+TILE/2,2,TILE/2);
  }else if(t==='turret'){
   ctx.fillStyle=COLORS.wall;ctx.fillRect(px,py,TILE,TILE);
   ctx.fillStyle=COLORS.turret;
   ctx.fillRect(px+TILE*.2,py+TILE*.2,TILE*.6,TILE*.6);
   ctx.fillStyle='#aaf';
   ctx.fillRect(px+TILE*.35,py+TILE*.1,TILE*.3,TILE*.3);
  }else if(t==='pit'){
   ctx.fillStyle=night?COLORS.empty_night:COLORS.empty_day;
   ctx.fillRect(px,py,TILE,TILE);
   ctx.fillStyle=COLORS.pit;
   ctx.beginPath();ctx.arc(px+TILE/2,py+TILE/2,TILE*.35,0,Math.PI*2);ctx.fill();
  }else if(t==='princess'){
   ctx.fillStyle=night?COLORS.empty_night:COLORS.empty_day;
   ctx.fillRect(px,py,TILE,TILE);
   drawPrincess(px+TILE/2,py+TILE/2);
  }else if(t==='tree'){
   ctx.fillStyle=night?COLORS.empty_night:COLORS.empty_day;
   ctx.fillRect(px,py,TILE,TILE);
   // trunk
   ctx.fillStyle='#654';ctx.fillRect(px+TILE*.4,py+TILE*.5,TILE*.2,TILE*.4);
   // leaves
   ctx.fillStyle=night?'#1a5a1a':'#2a8a2a';
   ctx.beginPath();ctx.arc(px+TILE*.5,py+TILE*.35,TILE*.35,0,Math.PI*2);ctx.fill();
   ctx.fillStyle=night?'#1a7a1a':'#3a9a3a';
   ctx.beginPath();ctx.arc(px+TILE*.5,py+TILE*.25,TILE*.25,0,Math.PI*2);ctx.fill();
  }else if(t==='rock'){
   ctx.fillStyle=night?COLORS.empty_night:COLORS.empty_day;
   ctx.fillRect(px,py,TILE,TILE);
   ctx.fillStyle='#777';
   ctx.beginPath();ctx.arc(px+TILE*.5,py+TILE*.55,TILE*.35,0,Math.PI*2);ctx.fill();
   ctx.fillStyle='#999';
   ctx.beginPath();ctx.arc(px+TILE*.4,py+TILE*.4,TILE*.2,0,Math.PI*2);ctx.fill();
  }else if(t==='water'){
   ctx.fillStyle=night?'#1a3a6a':'#2a6aaa';
   ctx.fillRect(px,py,TILE,TILE);
   // wave lines
   ctx.strokeStyle=night?'#2a5a8a':'#5a9adb';ctx.lineWidth=1.5;
   for(let w=0;w<2;w++){
    const wy=py+TILE*(.35+w*.3);
    ctx.beginPath();ctx.moveTo(px,wy);
    ctx.quadraticCurveTo(px+TILE*.25,wy-3+Math.sin(Date.now()/400+w)*2,px+TILE*.5,wy);
    ctx.quadraticCurveTo(px+TILE*.75,wy+3+Math.sin(Date.now()/400+w)*2,px+TILE,wy);
    ctx.stroke();
   }
  }else if(t==='portal'){
   ctx.fillStyle=night?COLORS.empty_night:COLORS.empty_day;
   ctx.fillRect(px,py,TILE,TILE);
   // swirling portal
   ctx.fillStyle=COLORS.portal;
   ctx.globalAlpha=.6+Math.sin(Date.now()/300)*.3;
   ctx.beginPath();ctx.arc(px+TILE/2,py+TILE/2,TILE*.4,0,Math.PI*2);ctx.fill();
   ctx.globalAlpha=1;
   ctx.fillStyle='#d0f';
   ctx.beginPath();ctx.arc(px+TILE/2,py+TILE/2,TILE*.2,0,Math.PI*2);ctx.fill();
  }
  // grid line
  ctx.strokeStyle='rgba(0,0,0,.15)';ctx.strokeRect(px,py,TILE,TILE);
 }

 // princess if grabbed (draw at current pos)
 if(princessGrabbed){
  drawPrincess(princessPos.x*TILE+TILE/2,princessPos.y*TILE+TILE/2);
 }

 // enemies
 for(const e of entities){
  const ex=e.x*TILE,ey=e.y*TILE-(e.flyOffset||0);
  const r=TILE*(e.size||.35);
  // body color by type
  if(e.type==='tank'){
   ctx.fillStyle=e.state==='carrying_to_portal'?'#a60':'#833';
   ctx.fillRect(ex-r,ey-r,r*2,r*2); // square tank
   ctx.fillStyle='#644';ctx.fillRect(ex-r+2,ey-r+2,r*2-4,r*2-4);
  }else if(e.type==='flyer'){
   // shadow on ground
   ctx.fillStyle='rgba(0,0,0,.25)';
   ctx.beginPath();ctx.ellipse(e.x*TILE,e.y*TILE+r,r*.6,r*.3,0,0,Math.PI*2);ctx.fill();
   ctx.fillStyle=e.state==='carrying_to_portal'?'#fa0':'#a6f';
   ctx.beginPath();ctx.arc(ex,ey,r,0,Math.PI*2);ctx.fill();
   // wings
   const wf=Math.sin(Date.now()/80)*r*.4;
   ctx.fillStyle='#c8f';
   ctx.beginPath();ctx.ellipse(ex-r*.8,ey-wf,r*.5,r*.3,-.3,0,Math.PI*2);ctx.fill();
   ctx.beginPath();ctx.ellipse(ex+r*.8,ey-wf,r*.5,r*.3,.3,0,Math.PI*2);ctx.fill();
  }else{
   ctx.fillStyle=e.state==='carrying_to_portal'?COLORS.enemyCarry:COLORS.enemy;
   ctx.beginPath();ctx.arc(ex,ey,r,0,Math.PI*2);ctx.fill();
  }
  // eyes
  ctx.fillStyle='#fff';
  ctx.fillRect(ex-r*.4,ey-r*.3,r*.3,r*.3);
  ctx.fillRect(ex+r*.1,ey-r*.3,r*.3,r*.3);
  ctx.fillStyle='#000';
  ctx.fillRect(ex-r*.3,ey-r*.2,r*.15,r*.15);
  ctx.fillRect(ex+r*.2,ey-r*.2,r*.15,r*.15);
  // hp bar
  if(e.hp<e.maxHp){
   ctx.fillStyle='#500';ctx.fillRect(ex-r,ey-r-4,r*2,3);
   ctx.fillStyle='#0f0';ctx.fillRect(ex-r,ey-r-4,r*2*(e.hp/e.maxHp),3);
  }
  if(e.state==='grabbing'){
   ctx.fillStyle='#ff0';ctx.font=`${TILE*.3}px monospace`;ctx.textAlign='center';
   ctx.fillText('...',ex,ey-r-6);
  }
 }

 // projectiles
 for(const p of projectiles){
  ctx.fillStyle='#ff0';
  ctx.beginPath();ctx.arc((p.cx||p.x)*TILE,(p.cy||p.y)*TILE,3,0,Math.PI*2);ctx.fill();
 }

 // floating texts
 for(const f of floatingTexts){
  ctx.globalAlpha=Math.max(0,f.timer);
  ctx.fillStyle=f.color;ctx.font=`bold ${TILE*.4}px monospace`;ctx.textAlign='center';
  ctx.fillText(f.text,f.x*TILE,f.y*TILE);
  ctx.globalAlpha=1;
 }
 ctx.restore();
}

function drawPrincess(cx,cy){
 const s=TILE*.35;
 // dress
 ctx.fillStyle='#f8a';
 ctx.beginPath();ctx.moveTo(cx-s,cy+s);ctx.lineTo(cx+s,cy+s);ctx.lineTo(cx,cy-s*.5);ctx.fill();
 // head
 ctx.fillStyle='#fda';
 ctx.beginPath();ctx.arc(cx,cy-s*.5,s*.5,0,Math.PI*2);ctx.fill();
 // crown
 ctx.fillStyle='#ff0';
 ctx.fillRect(cx-s*.4,cy-s*1.1,s*.8,s*.3);
 ctx.fillRect(cx-s*.4,cy-s*1.3,s*.2,s*.2);
 ctx.fillRect(cx+s*.2,cy-s*1.3,s*.2,s*.2);
 ctx.fillRect(cx-s*.1,cy-s*1.4,s*.2,s*.2);
}

// --- HUD ---
function updateHUD(){
 const info=document.getElementById('info');
 if(phase==='day')info.textContent=`Day ${nightNum+1} | Gold: ${gold} | Build your maze!`;
 else info.textContent=`Night ${nightNum} | Gold: ${gold} | Enemies: ${entities.length+spawnQueue.length}`;
}

function updateButtons(){
 document.getElementById('bWall').classList.toggle('sel',selectedTool==='wall');
 document.getElementById('bTurret').classList.toggle('sel',selectedTool==='turret');
 document.getElementById('bPit').classList.toggle('sel',selectedTool==='pit');
 document.getElementById('bRemove').classList.toggle('sel',selectedTool==='remove');
 document.getElementById('bNight').style.display=phase==='day'?'':'none';
}

// --- Touch/Click & Camera ---
function screenToGrid(sx,sy){
 const rect=canvas.getBoundingClientRect();
 const wx=(sx-rect.left-canvas.width/2)/zoom+camX;
 const wy=(sy-rect.top-canvas.height/2)/zoom+camY;
 return{x:wx/BASE_TILE|0,y:wy/BASE_TILE|0};
}

let touches={},lastPinchDist=0,isPanning=false,panStart={x:0,y:0},camStart={x:0,y:0};
let pointerDownTime=0,pointerDownPos={x:0,y:0};

canvas.addEventListener('pointerdown',e=>{
 touches[e.pointerId]={x:e.clientX,y:e.clientY};
 const tkeys=Object.keys(touches);
 if(tkeys.length===1){
  isPanning=false;pointerDownTime=Date.now();
  pointerDownPos={x:e.clientX,y:e.clientY};
  panStart={x:e.clientX,y:e.clientY};camStart={x:camX,y:camY};
 }
 if(tkeys.length===2){
  isPanning=true;
  const t=tkeys.map(k=>touches[k]);
  lastPinchDist=Math.hypot(t[0].x-t[1].x,t[0].y-t[1].y);
  panStart={x:(t[0].x+t[1].x)/2,y:(t[0].y+t[1].y)/2};camStart={x:camX,y:camY};
 }
});

canvas.addEventListener('pointermove',e=>{
 if(!touches[e.pointerId])return;
 touches[e.pointerId]={x:e.clientX,y:e.clientY};
 const tkeys=Object.keys(touches);
 if(tkeys.length===2){
  isPanning=true;
  const t=tkeys.map(k=>touches[k]);
  const dist=Math.hypot(t[0].x-t[1].x,t[0].y-t[1].y);
  if(lastPinchDist>0){
   zoom*=dist/lastPinchDist;
   zoom=Math.max(minZoom,Math.min(maxZoom,zoom));
  }
  lastPinchDist=dist;
  // pan with midpoint
  const mid={x:(t[0].x+t[1].x)/2,y:(t[0].y+t[1].y)/2};
  camX=camStart.x-(mid.x-panStart.x)/zoom;
  camY=camStart.y-(mid.y-panStart.y)/zoom;
 }else if(tkeys.length===1){
  const dx=e.clientX-panStart.x,dy=e.clientY-panStart.y;
  if(Math.abs(dx)+Math.abs(dy)>10)isPanning=true;
  if(isPanning){camX=camStart.x-dx/zoom;camY=camStart.y-dy/zoom;}
 }
});

canvas.addEventListener('pointerup',e=>{
 const wasPanning=isPanning;
 delete touches[e.pointerId];
 if(Object.keys(touches).length===0){isPanning=false;lastPinchDist=0;}
 // tap to place
 if(!wasPanning&&Date.now()-pointerDownTime<300&&gameState==='playing'){
  const g=screenToGrid(e.clientX,e.clientY);
  placeTile(g.x,g.y);
 }
});
canvas.addEventListener('pointercancel',e=>{delete touches[e.pointerId];});

// mouse wheel zoom
canvas.addEventListener('wheel',e=>{
 e.preventDefault();
 zoom*=e.deltaY<0?1.15:.87;
 zoom=Math.max(minZoom,Math.min(maxZoom,zoom));
},{passive:false});

function placeTile(tx,ty){
 if(tx<0||tx>=COLS||ty<0||ty>=ROWS)return;
 const tile=grid[ty][tx];
 if(selectedTool==='remove'){
  if(tile==='wall'){grid[ty][tx]='empty';gold+=2;calcFlowFields();}
  else if(tile==='turret'){grid[ty][tx]='empty';gold+=5;calcFlowFields();}
  else if(tile==='pit'){grid[ty][tx]='empty';gold+=3;}
  return;
 }
 if(selectedTool==='wall'&&phase==='day'){
  if(tile!=='empty'||gold<5)return;
  if(!canPlace(tx,ty)){floatingTexts.push({x:tx+.5,y:ty+.5,text:'BLOCKED!',timer:1,color:'#f00'});return;}
  grid[ty][tx]='wall';gold-=5;calcFlowFields();
 }else if(selectedTool==='turret'){
  if(gold<15){floatingTexts.push({x:tx+.5,y:ty+.5,text:'NO GOLD',timer:1,color:'#f00'});return;}
  if(tile!=='wall'){floatingTexts.push({x:tx+.5,y:ty+.5,text:'NEED WALL',timer:1,color:'#f00'});return;}
  grid[ty][tx]='turret';gold-=15;calcFlowFields();
 }else if(selectedTool==='pit'){
  if(tile!=='empty'||gold<10)return;
  grid[ty][tx]='pit';gold-=10;
 }
}

document.getElementById('bWall').onclick=()=>{selectedTool='wall';updateButtons();};
document.getElementById('bTurret').onclick=()=>{selectedTool='turret';updateButtons();};
document.getElementById('bPit').onclick=()=>{selectedTool='pit';updateButtons();};
document.getElementById('bRemove').onclick=()=>{selectedTool='remove';updateButtons();};
document.getElementById('bNight').onclick=()=>{if(phase==='day'&&gameState==='playing')startNight();};

// --- Overlay ---
function showOverlay(title,msg,btnText,cb){
 const ov=document.getElementById('overlay');
 ov.style.display='flex';
 ov.innerHTML=`<h1>${title}</h1><p>${msg}</p><button>${btnText}</button>`;
 ov.querySelector('button').onclick=()=>{ov.style.display='none';cb();};
}
function hideOverlay(){document.getElementById('overlay').style.display='none';}

document.getElementById('bStart').onclick=()=>{
 hideOverlay();
 gameState='playing';
 initGrid();addPortal();addPortal();addPortal();
 gold=50;score=0;nightNum=0;phase='day';
 selectedTool='wall';updateButtons();
 calcFlowFields();
};

// --- Main Loop ---
let lastTime=0;
function loop(time){
 const dt=Math.min((time-lastTime)/1000,.05);
 lastTime=time;

 if(gameState==='playing'){
  if(phase==='night'){
   stepWaves(dt);
   stepEnemies(dt);
   stepTurrets(dt);
   stepProjectiles(dt);
  }
  stepFloatingTexts(dt);
  render();
  updateHUD();
 }

 if(gameState==='win'){
  render();
  showOverlay('VICTORY!',`You defended the princess!<br>Score: ${score}<br>Gold remaining: ${gold}`,'Play Again',()=>{
   gameState='playing';initGrid();addPortal();gold=50;score=0;nightNum=0;phase='day';
   selectedTool='wall';updateButtons();calcFlowFields();
  });
  gameState='win_shown';
 }
 if(gameState==='lose'){
  render();
  showOverlay('DEFEAT!',`The princess was kidnapped!<br>Survived ${nightNum-1} nights<br>Score: ${score}`,'Try Again',()=>{
   gameState='playing';initGrid();addPortal();gold=50;score=0;nightNum=0;phase='day';
   selectedTool='wall';updateButtons();calcFlowFields();
  });
  gameState='lose_shown';
 }

 requestAnimationFrame(loop);
}

resize();
requestAnimationFrame(loop);
</script>
</body>
</html>
