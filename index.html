<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>Fortress Defense</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#111;touch-action:none;user-select:none;font-family:monospace}
#c{display:block;margin:0 auto}
#hud{position:fixed;bottom:0;left:0;right:0;background:#222;color:#eee;display:flex;align-items:center;justify-content:space-around;padding:6px 2px;font-size:13px;z-index:10;flex-wrap:wrap;gap:4px}
#hud button{background:#444;color:#eee;border:2px solid #666;padding:6px 10px;font-size:13px;font-family:monospace;border-radius:4px;min-width:60px}
#hud button.sel{border-color:#ff0;color:#ff0}
#hud button:active{background:#555}
@keyframes pulse{0%,100%{transform:scale(1)}50%{transform:scale(1.08)}}
#bNight{animation:pulse 1.2s infinite}
#info{text-align:center;width:100%;font-size:12px;margin-bottom:2px}
#overlay{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,.85);display:flex;flex-direction:column;align-items:center;justify-content:center;color:#eee;z-index:20;font-family:monospace;text-align:center}
#overlay h1{font-size:28px;margin-bottom:16px}
#overlay p{font-size:16px;margin-bottom:12px}
#overlay button{background:#555;color:#ff0;border:2px solid #ff0;padding:12px 32px;font-size:20px;font-family:monospace;border-radius:6px;margin-top:10px}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud">
 <div id="info"></div>
 <button id="bWall">Wall 5g</button>
 <button id="bTurret">Turret 15g</button>
 <button id="bPit">Pit 10g</button>
 <button id="bRemove">Remove</button>
 <button id="bNight" style="background:#a00;color:#ff0;border-color:#ff0;font-size:15px;font-weight:bold;padding:8px 14px">START NIGHT</button>
</div>
<div id="overlay"><h1>Fortress Defense</h1>
<p style="font-size:14px;line-height:1.6;max-width:340px;text-align:left;margin:0 auto 12px">
<b style="color:#ff0">Goal:</b> Protect the princess for 5 nights!<br>
Enemies spawn from <b style="color:#a0f">purple portals</b> and try to kidnap her.<br><br>
<b style="color:#ff0">Day Phase:</b><br>
&bull; Place <b style="color:#888">walls</b> (5g) to build a maze<br>
&bull; Walls must always leave a path open<br><br>
<b style="color:#ff0">Night Phase:</b><br>
&bull; Place <b style="color:#66f">turrets</b> (15g) on walls to shoot enemies<br>
&bull; Place <b style="color:#a52">pits</b> (10g) on ground to slow &amp; damage<br>
&bull; Tap "Start Night" when ready<br><br>
<b style="color:#ff0">Enemies:</b><br>
&bull; <b style="color:#e33">Normal</b> — standard runners<br>
&bull; <b style="color:#833">Tank</b> — slow, very tough<br>
&bull; <b style="color:#a6f">Flyer</b> — ignores walls<br>
&bull; <b style="color:#ff4">Sprinter</b> — 1HP but 3× speed, instant grab<br>
&bull; <b style="color:#ddf">Ghost</b> — phases through single walls<br>
&bull; <b style="color:#4f4">Healer</b> — restores HP to nearby enemies<br><br>
<b style="color:#ff0">Controls:</b> Tap to place, drag to pan, pinch to zoom<br>
<b style="color:#0f0">Tip:</b> Longer mazes = more gold from junctions!
</p>
<button id="bStart">START</button></div>
<script>
const canvas=document.getElementById('c'),ctx=canvas.getContext('2d');
const COLS=20,ROWS=32;
const BASE_TILE=16;
let TILE=BASE_TILE,offX=0,offY=0;
let camX=0,camY=0,zoom=1,minZoom=.5,maxZoom=2;
let grid=[],entities=[],projectiles=[],floatingTexts=[];
let phase='day',nightNum=0,gold=50,score=0;
let selectedTool='wall';
let flowToPrincess=null,flowToPortals=null;
let princessPos={x:10,y:16},princessHome={x:10,y:16};
let princessGrabbed=false,princessCarrier=null,princessWalking=false;
let waveTimer=0,waveCount=0,wavesTotal=0,nightActive=false;
let gameState='title'; // title, playing, win, lose
let spawnQueue=[];

// --- Resize ---
function resize(){
 const hud=document.getElementById('hud').offsetHeight||60;
 canvas.width=window.innerWidth;
 canvas.height=window.innerHeight-hud;
 // fit default zoom so map fills screen width
 const fitZoom=Math.min(canvas.width/(COLS*BASE_TILE),canvas.height/(ROWS*BASE_TILE));
 minZoom=fitZoom*.8;maxZoom=fitZoom*3;
 if(zoom<minZoom)zoom=minZoom;
 if(!window._zoomInit){zoom=fitZoom*.75;camX=(COLS*BASE_TILE)/2;camY=(ROWS*BASE_TILE)/2;window._zoomInit=true;}
}
window.addEventListener('resize',resize);

// --- Grid ---
function initGrid(){
 grid=[];
 for(let y=0;y<ROWS;y++){grid[y]=[];for(let x=0;x<COLS;x++)grid[y][x]='empty';}
 princessPos={x:6,y:10};princessHome={x:6,y:10};
 grid[princessHome.y][princessHome.x]='princess';
 princessGrabbed=false;princessCarrier=null;princessWalking=false;
 entities=[];projectiles=[];floatingTexts=[];spawnQueue=[];
 // scatter terrain
 const terrainTypes=['tree','rock','water'];
 let placed=0;
 while(placed<60){
  const x=Math.random()*COLS|0,y=Math.random()*ROWS|0;
  if(grid[y][x]!=='empty')continue;
  // keep a clear zone around princess and off edges (so portals can always spawn)
  if(Math.abs(x-princessHome.x)<=2&&Math.abs(y-princessHome.y)<=2)continue;
  if(x===0||x===COLS-1||y===0||y===ROWS-1)continue;
  const t=terrainTypes[Math.random()*3|0];
  grid[y][x]=t;
  placed++;
 }
}

function addPortal(){
 // random edge tile that is empty
 let attempts=0;
 while(attempts++<200){
  let side=Math.random()*4|0;
  let x,y;
  if(side===0){x=Math.random()*COLS|0;y=0;}
  else if(side===1){x=Math.random()*COLS|0;y=ROWS-1;}
  else if(side===2){x=0;y=Math.random()*ROWS|0;}
  else{x=COLS-1;y=Math.random()*ROWS|0;}
  if(grid[y][x]==='empty'){
   grid[y][x]='portal';
   const dist=bfs([{x,y}]);
   if(dist[princessHome.y][princessHome.x]===Infinity){grid[y][x]='empty';continue;}
   return;
  }
 }
}

// --- BFS Flow Fields ---
function neighbors(x,y){
 const n=[];
 if(x>0)n.push({x:x-1,y});if(x<COLS-1)n.push({x:x+1,y});
 if(y>0)n.push({x,y:y-1});if(y<ROWS-1)n.push({x,y:y+1});
 return n;
}
function isWalkable(x,y){const t=grid[y][x];return t!=='wall'&&t!=='turret'&&t!=='tree'&&t!=='rock'&&t!=='water';}

function bfs(starts){
 // returns dist map & parent map
 const dist=Array.from({length:ROWS},()=>new Float32Array(COLS).fill(Infinity));
 const q=[];
 for(const s of starts){dist[s.y][s.x]=0;q.push(s);}
 let qi=0;
 while(qi<q.length){
  const{x,y}=q[qi++];
  for(const n of neighbors(x,y)){
   if(isWalkable(n.x,n.y)&&dist[n.y][n.x]===Infinity){
    dist[n.y][n.x]=dist[y][x]+1;
    q.push(n);
   }
  }
 }
 return dist;
}

function calcFlowFields(){
 const pStart=(princessGrabbed||princessWalking)?{x:(princessPos.x+.5)|0,y:(princessPos.y+.5)|0}:princessHome;
 flowToPrincess=bfs([pStart]);
 // flow to nearest portal
 const portals=[];
 for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++)if(grid[y][x]==='portal')portals.push({x,y});
 flowToPortals=portals.length?bfs(portals):null;
}

function canPlace(x,y){
 // temporarily block this tile, check path from princess to any portal
 const old=grid[y][x];
 grid[y][x]='wall';
 const portals=[];
 for(let gy=0;gy<ROWS;gy++)for(let gx=0;gx<COLS;gx++)if(grid[gy][gx]==='portal')portals.push({x:gx,y:gy});
 const dist=bfs([princessHome]);
 let ok=false;
 for(const p of portals)if(dist[p.y][p.x]<Infinity){ok=true;break;}
 grid[y][x]=old;
 return ok;
}

function turretCount(){
 let c=0;for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++)if(grid[y][x]==='turret')c++;return c;
}
function turretCost(){return 15+turretCount()*5;}

// --- Enemies ---
function spawnEnemy(px,py,type){
 type=type||'normal';
 let hp,speed,size;
 const base=2+nightNum*.5;
 if(type==='normal'){hp=nightNum===1?2:3+nightNum*2;speed=base;size=.35;}
 else if(type==='tank'){hp=10+nightNum*5;speed=1.2+nightNum*.15;size=.5;}
 else if(type==='flyer'){hp=2+nightNum;speed=2+nightNum*.2;size=.25;}
 else if(type==='sprinter'){hp=1;speed=base*3;size=.28;}
 else if(type==='ghost'){hp=3+nightNum;speed=base*1.5;size=.3;}
 else if(type==='healer'){hp=8+nightNum*2;speed=base*.8;size=.32;}
 entities.push({x:px+.5,y:py+.5,hp,maxHp:hp,type,
  state:'moving_to_princess',speed,grabTimer:0,
  slowTimer:0,pitCooldown:0,size,flyOffset:0,wallsInRow:0});
}

function stepEnemies(dt){
 for(let i=entities.length-1;i>=0;i--){
  const e=entities[i];
  if(e.hp<=0){
   // drop princess if carrying
   if(e===princessCarrier){
    princessGrabbed=false;princessCarrier=null;
    // princess stays where the enemy died, then walks home
    princessWalking=true;
    calcFlowFields();
   }
   const reward=e.type==='tank'?5:e.type==='flyer'?3:1;
   gold+=reward;score+=10;
   floatingTexts.push({x:e.x,y:e.y,text:`+${reward}g`,timer:1,color:'#ff0'});
   entities.splice(i,1);continue;
  }
  let speed=e.speed*dt;
  if(e.slowTimer>0){speed*=.4;e.slowTimer-=dt;}

  // pit damage (flyers immune)
  const tx=e.x|0,ty=e.y|0;
  if(e.type!=='flyer'&&tx>=0&&tx<COLS&&ty>=0&&ty<ROWS&&grid[ty][tx]==='pit'&&e.pitCooldown<=0){
   e.hp-=2;e.slowTimer=1.5;e.pitCooldown=2;
   floatingTexts.push({x:e.x,y:e.y,text:'PIT!',timer:.8,color:'#f80'});
  }
  if(e.pitCooldown>0)e.pitCooldown-=dt;

  // healer aura — heal nearby allies
  if(e.type==='healer'){
   for(const other of entities){
    if(other===e)continue;
    const hx=other.x-e.x,hy=other.y-e.y;
    if(hx*hx+hy*hy<1.5*1.5&&other.hp<other.maxHp){
     other.hp=Math.min(other.maxHp,other.hp+dt);
    }
   }
  }

  if(e.state==='moving_to_princess'){
   const flow=flowToPrincess;
   if(!flow)continue;
   moveAlongFlow(e,flow,speed);
   // check if reached princess
   const dx=e.x-princessPos.x-.5,dy=e.y-princessPos.y-.5;
   if(!princessGrabbed&&!princessWalking&&dx*dx+dy*dy<.3){
    e.state='grabbing';
    e.grabTimer=e.type==='sprinter'?0:1; // sprinter grabs instantly
   }
  }else if(e.state==='grabbing'){
   e.grabTimer-=dt;
   if(e.grabTimer<=0){
    e.state='carrying_to_portal';
    princessGrabbed=true;princessCarrier=e;
    // Remove princess from grid
    grid[princessHome.y][princessHome.x]='empty';
    calcFlowFields();
   }
  }else if(e.state==='carrying_to_portal'){
   if(!flowToPortals)continue;
   moveAlongFlow(e,flowToPortals,speed*.6);
   princessPos={x:e.x-.5,y:e.y-.5};
   // check if reached portal
   const etx=e.x|0,ety=e.y|0;
   if(etx>=0&&etx<COLS&&ety>=0&&ety<ROWS&&grid[ety][etx]==='portal'){
    gameState='lose';
   }
  }
 }
}

function moveAlongFlow(e,flow,speed){
 if(e.type==='ghost'){
  // Straight-line toward target; phases through 1 consecutive wall, blocked by 2
  let tx,ty;
  if(e.state==='carrying_to_portal'){
   let best=Infinity;tx=e.x;ty=e.y;
   for(let gy=0;gy<ROWS;gy++)for(let gx=0;gx<COLS;gx++)if(grid[gy][gx]==='portal'){
    const d=(e.x-gx-.5)**2+(e.y-gy-.5)**2;if(d<best){best=d;tx=gx+.5;ty=gy+.5;}
   }
  }else{tx=princessPos.x+.5;ty=princessPos.y+.5;}
  const dx=tx-e.x,dy=ty-e.y,dist=Math.sqrt(dx*dx+dy*dy);
  if(dist<.05)return;
  const nx=e.x+dx/dist*Math.min(speed,dist);
  const ny=e.y+dy/dist*Math.min(speed,dist);
  const ntx=nx|0,nty=ny|0;
  const curTile=grid[e.y|0]&&grid[e.y|0][e.x|0];
  const curWall=curTile==='wall'||curTile==='turret'||curTile==='tree'||curTile==='rock'||curTile==='water';
  const nextTile=ntx>=0&&ntx<COLS&&nty>=0&&nty<ROWS?grid[nty][ntx]:'';
  const nextWall=nextTile==='wall'||nextTile==='turret'||nextTile==='tree'||nextTile==='rock'||nextTile==='water';
  // track consecutive wall tiles crossed
  const prevTX=e.x|0,prevTY=e.y|0;
  if(nextWall&&curWall){return;} // double wall blocks
  e.x=nx;e.y=ny;
  const newTX=e.x|0,newTY=e.y|0;
  if(newTX!==prevTX||newTY!==prevTY){
   const t=grid[newTY]&&grid[newTY][newTX];
   const inWall=t==='wall'||t==='turret'||t==='tree'||t==='rock'||t==='water';
   e.wallsInRow=inWall?(e.wallsInRow||0)+1:0;
  }
  return;
 }
 if(e.type==='flyer'){
  // fly straight toward target (ignore walls)
  let tx,ty;
  if(e.state==='carrying_to_portal'||e.state==='moving_to_princess'&&princessGrabbed){
   // find nearest portal
   let best=Infinity;tx=e.x;ty=e.y;
   for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++)if(grid[y][x]==='portal'){
    const d=(e.x-x-.5)**2+(e.y-y-.5)**2;if(d<best){best=d;tx=x+.5;ty=y+.5;}
   }
  }else{tx=princessPos.x+.5;ty=princessPos.y+.5;}
  const dx=tx-e.x,dy=ty-e.y,dist=Math.sqrt(dx*dx+dy*dy);
  if(dist>.05){e.x+=dx/dist*Math.min(speed,dist);e.y+=dy/dist*Math.min(speed,dist);}
  e.flyOffset=Math.sin(Date.now()/150)*3;
  return;
 }
 const cx=e.x|0,cy=e.y|0;
 let bestD=flow[cy]?flow[cy][cx]:Infinity;
 let bx=cx,by=cy;
 for(const n of neighbors(cx,cy)){
  if(!isWalkable(n.x,n.y))continue;
  const d=flow[n.y][n.x];
  if(d<bestD||(d===bestD&&Math.random()<.3)){bestD=d;bx=n.x;by=n.y;}
 }
 const tx=bx+.5,ty=by+.5;
 const dx=tx-e.x,dy=ty-e.y;
 const dist=Math.sqrt(dx*dx+dy*dy);
 if(dist>.05){e.x+=dx/dist*Math.min(speed,dist);e.y+=dy/dist*Math.min(speed,dist);}
}

// --- Turrets ---
function stepTurrets(dt){
 for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++){
  if(grid[y][x]!=='turret')continue;
  // find turret data
  if(!grid[y]._turrets)grid[y]._turrets={};
  if(!grid[y]._turrets[x])grid[y]._turrets[x]={cd:0};
  const t=grid[y]._turrets[x];
  t.cd-=dt;
  if(t.cd>0)continue;
  // find nearest enemy in range 3.5
  let best=null,bestD=3.5*3.5;
  for(const e of entities){
   const dx=e.x-(x+.5),dy=e.y-(y+.5),d2=dx*dx+dy*dy;
   if(d2<bestD){bestD=d2;best=e;}
  }
  if(best){
   t.cd=.5;
   projectiles.push({x:x+.5,y:y+.5,tx:best.x,ty:best.y,timer:.2,target:best,dmg:2+Math.floor(nightNum/2)});
  }
 }
}

function stepProjectiles(dt){
 for(let i=projectiles.length-1;i>=0;i--){
  const p=projectiles[i];
  p.timer-=dt;
  const dur=p.isPrincessShot?.3:.2;
  const prog=1-Math.max(0,p.timer)/dur;
  p.cx=p.x+(p.tx-p.x)*prog;
  p.cy=p.y+(p.ty-p.y)*prog;
  if(p.timer<=0){
   if(p.isPrincessShot){
    // hit nearest enemy within 1 tile of impact
    let best=null,bestD=1;
    for(const e of entities){
     const dx=e.x-p.tapX,dy=e.y-p.tapY,d=Math.sqrt(dx*dx+dy*dy);
     if(d<bestD){bestD=d;best=e;}
    }
    if(best&&best.hp>0){
     best.hp-=p.dmg;
     floatingTexts.push({x:best.x,y:best.y-.5,text:`-${p.dmg}`,timer:.8,color:'#f8f'});
    }
   }else{
    if(p.target&&p.target.hp>0)p.target.hp-=p.dmg;
   }
   projectiles.splice(i,1);
  }
 }
}

// --- Floating Text ---
function stepFloatingTexts(dt){
 for(let i=floatingTexts.length-1;i>=0;i--){
  const f=floatingTexts[i];
  f.timer-=dt;f.y-=dt*.8;
  if(f.timer<=0)floatingTexts.splice(i,1);
 }
}

// --- Wave Management ---
function startNight(){
 if(phase==='night')return;
 phase='night';nightNum++;
 spawnQueue=[];waveCount=0;
 const portals=[];
 for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++)if(grid[y][x]==='portal')portals.push({x,y});

 function addWave(seq,startTime,interval){
  for(let i=0;i<seq.length;i++){
   const p=portals[i%portals.length];
   spawnQueue.push({x:p.x,y:p.y,delay:startTime+i*interval,type:seq[i]});
  }
 }

 const N='normal',T='tank',F='flyer',S='sprinter',G='ghost',H='healer';
 if(nightNum===1){
  addWave([N,N,N,N,N,N,N,N,N,N,N,N],1,1.5);
 }else if(nightNum===2){
  addWave([N,N,N,N,S,N,N,N,N,T,N,N,N,S,T,S,T,S,T,N,N,N],1,1.0);
 }else if(nightNum===3){
  addWave([N,N,F,N,N,F,S,N,N,F,N,N,F,S,N,N,F,N,N,F,S,N,F,S,N,F,S,N,F,N],1,0.7);
 }else if(nightNum===4){
  const g1=[N,N,N,N,N,N,N,N,F,F,F,T,T,H,N,N,N,G,G,F,S];
  const g2=[G,G,N,N,N,T,T,F,F,F,H,N,N,N,N,N,G,G,H,T];
  addWave(g1,1,0.5);
  addWave(g2,1+g1.length*0.5+4,0.5);
 }else if(nightNum===5){
  const r1=[S,S,N,N,N,N,F,F,H,T,T,T,N,N,N,G,G,S,F,F,F,F,T,T,N,N,N,N,N,H,G,G,S];
  const r2=[S,S,N,N,N,N,N,G,G,G,T,T,T,F,F,H,N,N,N,N,G,G,T,T,T,S,S,F,F,F,F,N,N,N,H,T,T];
  addWave(r1,1,0.3);
  addWave(r2,1+r1.length*0.3+5,0.2);
 }

 wavesTotal=spawnQueue.length;
 nightActive=true;waveTimer=0;
 calcFlowFields();
 selectedTool='turret';updateButtons();
}

function stepWaves(dt){
 if(!nightActive)return;
 waveTimer+=dt;
 for(let i=spawnQueue.length-1;i>=0;i--){
  if(waveTimer>=spawnQueue[i].delay){
   spawnEnemy(spawnQueue[i].x,spawnQueue[i].y,spawnQueue[i].type);
   waveCount++;spawnQueue.splice(i,1);
  }
 }
 if(spawnQueue.length===0&&entities.length===0){
  // night over
  nightActive=false;
  if(nightNum>=5){gameState='win';return;}
  phase='day';
  addPortal();
  // restore princess if not grabbed or mid-walk
  princessWalking=false;
  princessPos={...princessHome};
  grid[princessHome.y][princessHome.x]='princess';
  const nightBonus=[0,25,20,20,25,0];
  gold+=nightBonus[nightNum]||0;
  selectedTool='wall';updateButtons();
  calcFlowFields();
 }
}

// --- Render ---
const COLORS={
 empty_day:'#5a8f3c',empty_night:'#2a4f2c',
 wall:'#888',turret:'#66f',pit:'#3a2010',
 princess:'#f8a',portal:'#a0f',
 enemy:'#e33',enemyCarry:'#f80'
};

function render(){
 const night=phase==='night';
 TILE=BASE_TILE*zoom;
 ctx.fillStyle=night?'#1a2a1a':'#3a6a2a';
 ctx.fillRect(0,0,canvas.width,canvas.height);
 ctx.save();
 ctx.translate(canvas.width/2-camX*zoom,canvas.height/2-camY*zoom);

 // tiles
 for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++){
  const t=grid[y][x];
  const px=x*TILE,py=y*TILE;
  if(t==='empty'){
   ctx.fillStyle=night?COLORS.empty_night:COLORS.empty_day;
   ctx.fillRect(px,py,TILE,TILE);
  }else if(t==='wall'){
   ctx.fillStyle=COLORS.wall;ctx.fillRect(px,py,TILE,TILE);
   // brick pattern
   ctx.fillStyle='#777';
   ctx.fillRect(px,py+TILE/2-1,TILE,2);
   ctx.fillRect(px+TILE/2-1,py,2,TILE/2);
   ctx.fillRect(px+TILE/4-1,py+TILE/2,2,TILE/2);
  }else if(t==='turret'){
   ctx.fillStyle=COLORS.wall;ctx.fillRect(px,py,TILE,TILE);
   ctx.fillStyle=COLORS.turret;
   ctx.fillRect(px+TILE*.2,py+TILE*.2,TILE*.6,TILE*.6);
   ctx.fillStyle='#aaf';
   ctx.fillRect(px+TILE*.35,py+TILE*.1,TILE*.3,TILE*.3);
  }else if(t==='pit'){
   ctx.fillStyle=night?COLORS.empty_night:COLORS.empty_day;
   ctx.fillRect(px,py,TILE,TILE);
   ctx.fillStyle=COLORS.pit;
   ctx.beginPath();ctx.arc(px+TILE/2,py+TILE/2,TILE*.35,0,Math.PI*2);ctx.fill();
  }else if(t==='princess'){
   ctx.fillStyle=night?COLORS.empty_night:COLORS.empty_day;
   ctx.fillRect(px,py,TILE,TILE);
   drawPrincess(px+TILE/2,py+TILE/2);
  }else if(t==='tree'){
   ctx.fillStyle=night?COLORS.empty_night:COLORS.empty_day;
   ctx.fillRect(px,py,TILE,TILE);
   // trunk
   ctx.fillStyle='#654';ctx.fillRect(px+TILE*.4,py+TILE*.5,TILE*.2,TILE*.4);
   // leaves
   ctx.fillStyle=night?'#1a5a1a':'#2a8a2a';
   ctx.beginPath();ctx.arc(px+TILE*.5,py+TILE*.35,TILE*.35,0,Math.PI*2);ctx.fill();
   ctx.fillStyle=night?'#1a7a1a':'#3a9a3a';
   ctx.beginPath();ctx.arc(px+TILE*.5,py+TILE*.25,TILE*.25,0,Math.PI*2);ctx.fill();
  }else if(t==='rock'){
   ctx.fillStyle=night?COLORS.empty_night:COLORS.empty_day;
   ctx.fillRect(px,py,TILE,TILE);
   ctx.fillStyle='#777';
   ctx.beginPath();ctx.arc(px+TILE*.5,py+TILE*.55,TILE*.35,0,Math.PI*2);ctx.fill();
   ctx.fillStyle='#999';
   ctx.beginPath();ctx.arc(px+TILE*.4,py+TILE*.4,TILE*.2,0,Math.PI*2);ctx.fill();
  }else if(t==='water'){
   ctx.fillStyle=night?'#1a3a6a':'#2a6aaa';
   ctx.fillRect(px,py,TILE,TILE);
   // wave lines
   ctx.strokeStyle=night?'#2a5a8a':'#5a9adb';ctx.lineWidth=1.5;
   for(let w=0;w<2;w++){
    const wy=py+TILE*(.35+w*.3);
    ctx.beginPath();ctx.moveTo(px,wy);
    ctx.quadraticCurveTo(px+TILE*.25,wy-3+Math.sin(Date.now()/400+w)*2,px+TILE*.5,wy);
    ctx.quadraticCurveTo(px+TILE*.75,wy+3+Math.sin(Date.now()/400+w)*2,px+TILE,wy);
    ctx.stroke();
   }
  }else if(t==='portal'){
   ctx.fillStyle=night?COLORS.empty_night:COLORS.empty_day;
   ctx.fillRect(px,py,TILE,TILE);
   // swirling portal
   ctx.fillStyle=COLORS.portal;
   ctx.globalAlpha=.6+Math.sin(Date.now()/300)*.3;
   ctx.beginPath();ctx.arc(px+TILE/2,py+TILE/2,TILE*.4,0,Math.PI*2);ctx.fill();
   ctx.globalAlpha=1;
   ctx.fillStyle='#d0f';
   ctx.beginPath();ctx.arc(px+TILE/2,py+TILE/2,TILE*.2,0,Math.PI*2);ctx.fill();
  }
  // grid line
  ctx.strokeStyle='rgba(0,0,0,.15)';ctx.strokeRect(px,py,TILE,TILE);
 }

 // princess if grabbed (draw at current pos)
 if(princessGrabbed||princessWalking){
  drawPrincess(princessPos.x*TILE+TILE/2,princessPos.y*TILE+TILE/2);
 }

 // enemies
 for(const e of entities){
  const ex=e.x*TILE,ey=e.y*TILE-(e.flyOffset||0);
  const r=TILE*(e.size||.35);
  // body color by type
  if(e.type==='tank'){
   ctx.fillStyle=e.state==='carrying_to_portal'?'#a60':'#833';
   ctx.fillRect(ex-r,ey-r,r*2,r*2); // square tank
   ctx.fillStyle='#644';ctx.fillRect(ex-r+2,ey-r+2,r*2-4,r*2-4);
  }else if(e.type==='flyer'){
   // shadow on ground
   ctx.fillStyle='rgba(0,0,0,.25)';
   ctx.beginPath();ctx.ellipse(e.x*TILE,e.y*TILE+r,r*.6,r*.3,0,0,Math.PI*2);ctx.fill();
   ctx.fillStyle=e.state==='carrying_to_portal'?'#fa0':'#a6f';
   ctx.beginPath();ctx.arc(ex,ey,r,0,Math.PI*2);ctx.fill();
   // wings
   const wf=Math.sin(Date.now()/80)*r*.4;
   ctx.fillStyle='#c8f';
   ctx.beginPath();ctx.ellipse(ex-r*.8,ey-wf,r*.5,r*.3,-.3,0,Math.PI*2);ctx.fill();
   ctx.beginPath();ctx.ellipse(ex+r*.8,ey-wf,r*.5,r*.3,.3,0,Math.PI*2);ctx.fill();
  }else if(e.type==='sprinter'){
   ctx.fillStyle=e.state==='carrying_to_portal'?'#fa0':'#ff4';
   ctx.beginPath();ctx.arc(ex,ey,r,0,Math.PI*2);ctx.fill();
   // speed lines
   ctx.strokeStyle='rgba(255,255,0,.5)';ctx.lineWidth=1;
   ctx.beginPath();ctx.moveTo(ex-r*1.2,ey-r*.3);ctx.lineTo(ex-r*.5,ey-r*.3);ctx.stroke();
   ctx.beginPath();ctx.moveTo(ex-r*1.4,ey+r*.1);ctx.lineTo(ex-r*.5,ey+r*.1);ctx.stroke();
  }else if(e.type==='ghost'){
   ctx.globalAlpha=0.65;
   ctx.fillStyle=e.state==='carrying_to_portal'?'rgba(255,200,100,.7)':'rgba(220,220,255,.7)';
   ctx.beginPath();ctx.arc(ex,ey,r,0,Math.PI*2);ctx.fill();
   // wavy bottom
   ctx.fillStyle=e.state==='carrying_to_portal'?'rgba(255,200,100,.5)':'rgba(200,200,255,.5)';
   ctx.beginPath();
   ctx.arc(ex,ey+r*.5,r*.6,0,Math.PI);ctx.fill();
   ctx.globalAlpha=1;
  }else if(e.type==='healer'){
   // heal aura ring
   ctx.strokeStyle='rgba(80,255,80,.3)';ctx.lineWidth=3;
   ctx.beginPath();ctx.arc(ex,ey,1.5*TILE,0,Math.PI*2);ctx.stroke();
   ctx.fillStyle=e.state==='carrying_to_portal'?'#fa0':'#4f4';
   ctx.beginPath();ctx.arc(ex,ey,r,0,Math.PI*2);ctx.fill();
   // cross symbol
   ctx.fillStyle='#fff';
   ctx.fillRect(ex-r*.12,ey-r*.55,r*.24,r*.55*2);
   ctx.fillRect(ex-r*.55,ey-r*.12,r*.55*2,r*.24);
  }else{
   ctx.fillStyle=e.state==='carrying_to_portal'?COLORS.enemyCarry:COLORS.enemy;
   ctx.beginPath();ctx.arc(ex,ey,r,0,Math.PI*2);ctx.fill();
  }
  // eyes
  ctx.fillStyle='#fff';
  ctx.fillRect(ex-r*.4,ey-r*.3,r*.3,r*.3);
  ctx.fillRect(ex+r*.1,ey-r*.3,r*.3,r*.3);
  ctx.fillStyle='#000';
  ctx.fillRect(ex-r*.3,ey-r*.2,r*.15,r*.15);
  ctx.fillRect(ex+r*.2,ey-r*.2,r*.15,r*.15);
  // hp bar
  if(e.hp<e.maxHp){
   ctx.fillStyle='#500';ctx.fillRect(ex-r,ey-r-4,r*2,3);
   ctx.fillStyle='#0f0';ctx.fillRect(ex-r,ey-r-4,r*2*(e.hp/e.maxHp),3);
  }
  if(e.state==='grabbing'){
   ctx.fillStyle='#ff0';ctx.font=`${TILE*.3}px monospace`;ctx.textAlign='center';
   ctx.fillText('...',ex,ey-r-6);
  }
 }

 // projectiles
 for(const p of projectiles){
  ctx.fillStyle=p.isPrincessShot?'#f8f':'#ff0';
  ctx.beginPath();ctx.arc((p.cx||p.x)*TILE,(p.cy||p.y)*TILE,p.isPrincessShot?4:3,0,Math.PI*2);ctx.fill();
 }

 // floating texts
 for(const f of floatingTexts){
  ctx.globalAlpha=Math.max(0,f.timer);
  ctx.fillStyle=f.color;ctx.font=`bold ${TILE*.4}px monospace`;ctx.textAlign='center';
  ctx.fillText(f.text,f.x*TILE,f.y*TILE);
  ctx.globalAlpha=1;
 }
 ctx.restore();
}

function drawPrincess(cx,cy){
 const s=TILE*.35;
 // cooldown ring (drawn behind princess)
 if(phase==='night'){
  const r=s*1.7;
  const frac=Math.max(0,princessAttackCooldown)/1;
  if(frac>0){
   // grey background ring
   ctx.strokeStyle='rgba(255,255,255,.2)';ctx.lineWidth=3;
   ctx.beginPath();ctx.arc(cx,cy,r,0,Math.PI*2);ctx.stroke();
   // remaining cooldown arc (red)
   ctx.strokeStyle='#f44';ctx.lineWidth=3;
   ctx.beginPath();ctx.arc(cx,cy,r,-Math.PI/2,-Math.PI/2+frac*Math.PI*2);ctx.stroke();
  }else{
   // ready: glowing yellow ring
   ctx.strokeStyle=`rgba(255,255,0,${.5+Math.sin(Date.now()/150)*.3})`;ctx.lineWidth=3;
   ctx.beginPath();ctx.arc(cx,cy,r,0,Math.PI*2);ctx.stroke();
  }
 }
 // dress
 ctx.fillStyle='#f8a';
 ctx.beginPath();ctx.moveTo(cx-s,cy+s);ctx.lineTo(cx+s,cy+s);ctx.lineTo(cx,cy-s*.5);ctx.fill();
 // head
 ctx.fillStyle='#fda';
 ctx.beginPath();ctx.arc(cx,cy-s*.5,s*.5,0,Math.PI*2);ctx.fill();
 // crown
 ctx.fillStyle='#ff0';
 ctx.fillRect(cx-s*.4,cy-s*1.1,s*.8,s*.3);
 ctx.fillRect(cx-s*.4,cy-s*1.3,s*.2,s*.2);
 ctx.fillRect(cx+s*.2,cy-s*1.3,s*.2,s*.2);
 ctx.fillRect(cx-s*.1,cy-s*1.4,s*.2,s*.2);
}

// --- HUD ---
function updateHUD(){
 const info=document.getElementById('info');
 if(phase==='day')info.textContent=`Day ${nightNum+1} | Gold: ${gold} | Build your maze!`;
 else info.textContent=`Night ${nightNum} | Gold: ${gold} | Enemies: ${entities.length+spawnQueue.length}`;
 document.getElementById('bTurret').textContent=`Turret ${turretCost()}g`;
}

function updateButtons(){
 document.getElementById('bWall').classList.toggle('sel',selectedTool==='wall');
 document.getElementById('bTurret').textContent=`Turret ${turretCost()}g`;
 document.getElementById('bTurret').classList.toggle('sel',selectedTool==='turret');
 document.getElementById('bPit').classList.toggle('sel',selectedTool==='pit');
 document.getElementById('bRemove').classList.toggle('sel',selectedTool==='remove');
 document.getElementById('bNight').style.display=phase==='day'?'':'none';
}

// --- Touch/Click & Camera ---
function screenToGrid(sx,sy){
 const rect=canvas.getBoundingClientRect();
 const wx=(sx-rect.left-canvas.width/2)/zoom+camX;
 const wy=(sy-rect.top-canvas.height/2)/zoom+camY;
 return{x:wx/BASE_TILE|0,y:wy/BASE_TILE|0};
}

let touches={},lastPinchDist=0,isPanning=false,panStart={x:0,y:0},camStart={x:0,y:0};
let pointerDownTime=0,pointerDownPos={x:0,y:0};
let princessAttackCooldown=0;

canvas.addEventListener('pointerdown',e=>{
 touches[e.pointerId]={x:e.clientX,y:e.clientY};
 const tkeys=Object.keys(touches);
 if(tkeys.length===1){
  isPanning=false;pointerDownTime=Date.now();
  pointerDownPos={x:e.clientX,y:e.clientY};
  panStart={x:e.clientX,y:e.clientY};camStart={x:camX,y:camY};
 }
 if(tkeys.length===2){
  isPanning=true;
  const t=tkeys.map(k=>touches[k]);
  lastPinchDist=Math.hypot(t[0].x-t[1].x,t[0].y-t[1].y);
  panStart={x:(t[0].x+t[1].x)/2,y:(t[0].y+t[1].y)/2};camStart={x:camX,y:camY};
 }
});

canvas.addEventListener('pointermove',e=>{
 if(!touches[e.pointerId])return;
 touches[e.pointerId]={x:e.clientX,y:e.clientY};
 const tkeys=Object.keys(touches);
 if(tkeys.length===2){
  isPanning=true;
  const t=tkeys.map(k=>touches[k]);
  const dist=Math.hypot(t[0].x-t[1].x,t[0].y-t[1].y);
  if(lastPinchDist>0){
   zoom*=dist/lastPinchDist;
   zoom=Math.max(minZoom,Math.min(maxZoom,zoom));
  }
  lastPinchDist=dist;
  // pan with midpoint
  const mid={x:(t[0].x+t[1].x)/2,y:(t[0].y+t[1].y)/2};
  camX=camStart.x-(mid.x-panStart.x)/zoom;
  camY=camStart.y-(mid.y-panStart.y)/zoom;
 }else if(tkeys.length===1){
  const dx=e.clientX-panStart.x,dy=e.clientY-panStart.y;
  if(Math.abs(dx)+Math.abs(dy)>10)isPanning=true;
  if(isPanning){camX=camStart.x-dx/zoom;camY=camStart.y-dy/zoom;}
 }
});

canvas.addEventListener('pointerup',e=>{
 const wasPanning=isPanning;
 delete touches[e.pointerId];
 if(Object.keys(touches).length===0){isPanning=false;lastPinchDist=0;}
 // tap to place or attack enemy
 if(!wasPanning&&Date.now()-pointerDownTime<300&&gameState==='playing'){
  // during night, princess shoots toward tap
  if(phase==='night'&&princessAttackCooldown<=0){
   const rect=canvas.getBoundingClientRect();
   const wx=(e.clientX-rect.left-canvas.width/2)/zoom+camX;
   const wy=(e.clientY-rect.top-canvas.height/2)/zoom+camY;
   const tx=wx/BASE_TILE,ty=wy/BASE_TILE;
   const px=princessPos.x+.5,py=princessPos.y+.5;
   const dmg=2+Math.floor(nightNum/2);
   projectiles.push({x:px,y:py,tx,ty,timer:.3,target:null,dmg,isPrincessShot:true,tapX:tx,tapY:ty});
   princessAttackCooldown=1;
   return;
  }
  const g=screenToGrid(e.clientX,e.clientY);
  placeTile(g.x,g.y);
 }
});
canvas.addEventListener('pointercancel',e=>{delete touches[e.pointerId];});

// mouse wheel zoom
canvas.addEventListener('wheel',e=>{
 e.preventDefault();
 zoom*=e.deltaY<0?1.15:.87;
 zoom=Math.max(minZoom,Math.min(maxZoom,zoom));
},{passive:false});

function placeTile(tx,ty){
 if(tx<0||tx>=COLS||ty<0||ty>=ROWS)return;
 const tile=grid[ty][tx];
 if(selectedTool==='remove'){
  if(tile==='wall'){grid[ty][tx]='empty';gold+=2;calcFlowFields();}
  else if(tile==='turret'){grid[ty][tx]='empty';gold+=5;calcFlowFields();}
  else if(tile==='pit'){grid[ty][tx]='empty';gold+=3;}
  return;
 }
 if(selectedTool==='wall'&&phase==='day'){
  if(tile!=='empty'||gold<5)return;
  if(!canPlace(tx,ty)){floatingTexts.push({x:tx+.5,y:ty+.5,text:'BLOCKED!',timer:1,color:'#f00'});return;}
  grid[ty][tx]='wall';gold-=5;calcFlowFields();
 }else if(selectedTool==='turret'){
  const tc=turretCost();
  if(gold<tc){floatingTexts.push({x:tx+.5,y:ty+.5,text:'NO GOLD',timer:1,color:'#f00'});return;}
  if(tile!=='wall'){floatingTexts.push({x:tx+.5,y:ty+.5,text:'NEED WALL',timer:1,color:'#f00'});return;}
  grid[ty][tx]='turret';gold-=tc;calcFlowFields();
 }else if(selectedTool==='pit'){
  if(tile!=='empty'||gold<10)return;
  grid[ty][tx]='pit';gold-=10;
 }
}

document.getElementById('bWall').onclick=()=>{selectedTool='wall';updateButtons();};
document.getElementById('bTurret').onclick=()=>{selectedTool='turret';updateButtons();};
document.getElementById('bPit').onclick=()=>{selectedTool='pit';updateButtons();};
document.getElementById('bRemove').onclick=()=>{selectedTool='remove';updateButtons();};
document.getElementById('bNight').onclick=()=>{if(phase==='day'&&gameState==='playing')startNight();};

// --- Overlay ---
function showOverlay(title,msg,btnText,cb){
 const ov=document.getElementById('overlay');
 ov.style.display='flex';
 ov.innerHTML=`<h1>${title}</h1><p>${msg}</p><button>${btnText}</button>`;
 ov.querySelector('button').onclick=()=>{ov.style.display='none';cb();};
}
function hideOverlay(){document.getElementById('overlay').style.display='none';}

document.getElementById('bStart').onclick=()=>{
 hideOverlay();
 gameState='playing';
 initGrid();addPortal();addPortal();addPortal();
 gold=50;score=0;nightNum=0;phase='day';
 selectedTool='wall';updateButtons();
 calcFlowFields();
};

// --- Main Loop ---
let lastTime=0;
function loop(time){
 const dt=Math.min((time-lastTime)/1000,.05);
 lastTime=time;

 if(gameState==='playing'){
  if(princessAttackCooldown>0)princessAttackCooldown-=dt;
 if(princessWalking){
  const tx=princessHome.x+.5,ty=princessHome.y+.5;
  const cx=princessPos.x+.5,cy=princessPos.y+.5;
  const dx=tx-cx,dy=ty-cy,dist=Math.sqrt(dx*dx+dy*dy);
  const spd=2*dt;
  if(dist<=spd){
   princessPos={x:princessHome.x,y:princessHome.y};
   princessWalking=false;
   grid[princessHome.y][princessHome.x]='princess';
  }else{
   princessPos={x:princessPos.x+dx/dist*spd,y:princessPos.y+dy/dist*spd};
  }
 }
  if(phase==='night'){
   if(princessGrabbed||princessWalking)calcFlowFields();
   stepWaves(dt);
   stepEnemies(dt);
   stepTurrets(dt);
   stepProjectiles(dt);
  }
  stepFloatingTexts(dt);
  render();
  updateHUD();
 }

 if(gameState==='win'){
  render();
  showOverlay('VICTORY!',`You defended the princess!<br>Score: ${score}<br>Gold remaining: ${gold}`,'Play Again',()=>{
   gameState='playing';initGrid();addPortal();addPortal();addPortal();gold=50;score=0;nightNum=0;phase='day';
   selectedTool='wall';updateButtons();calcFlowFields();
  });
  gameState='win_shown';
 }
 if(gameState==='lose'){
  render();
  showOverlay('DEFEAT!',`The princess was kidnapped!<br>Survived ${nightNum-1} nights<br>Score: ${score}`,'Try Again',()=>{
   gameState='playing';initGrid();addPortal();addPortal();addPortal();gold=50;score=0;nightNum=0;phase='day';
   selectedTool='wall';updateButtons();calcFlowFields();
  });
  gameState='lose_shown';
 }

 requestAnimationFrame(loop);
}

resize();
requestAnimationFrame(loop);
</script>
</body>
</html>
